<%= partial 'tile-reference/property-blueprint', locals: {
    description: 'This holds multiple records of a group of custom defined properties.',
    credential: false,
    auto_generatable: false,
    operator_configurable: true,
    allows_default_to_be_specified: true,
    additional_default_description: <<~DESC,
      If specified, the default value must be an array where each item of the array has the keys and values which are appropriate for the property blueprints provided. For the example below, a default value could be:
      <pre><code>default:
        - name: sam
          public_key: ssh-rsa AAAAB3NzaC1yc2EAAAAD...
          sudo: true
      </code></pre>
      DESC
    value_accessor_description: <<~DESC,
      An array of objects whose keys are the property names specified under <code>property_blueprints</code>,
      and whose values are the <code>.value</code> for each property. For example, if a collection \"albums\"
      had properties: title (string) and explicit (boolean), <code>(( albums.value ))</code> would render:
      <pre><code>[\n&nbsp;&nbsp;{title: 'album-one', explicit: true},\n&nbsp;&nbsp;{title: 'album-two', explicit: false}\n]</code></pre>
      DESC
    value_present_accessor_description: nil, # collections do not support `.value_present?`
    additional_property_blueprint_attributes: [
      {
        name: 'property_blueprints',
        description: <<~DESC,
          A group of property blueprints that each record will have. Any type and combination
          of property types can be used except collections and selectors which cannot be nested
          inside of collections.
          DESC
      },
      {
        name: 'named_manifests',
        description: <<~DESC,
          An array of objects each containing a <code>name</code> and a <code>manifest</code>.
          The manifest specifies the YAML which can be used with <code>parsed_manifest(name)</code>
          where the manifest will be interpolated for each record in the collection.
          The manifest has a special property level, <code>current_record</code>, which has
          all the properties in a record of the collection.  The provided example below shows
          have <code>named_manifest</code>, <code>current_record</code>, and <code>parsed_manifest</code>
          together to render a collection in a BOSH manifest.
          DESC
      },
      {
        name: 'Logical Keys for GitOps style workflows',
        description: <<~DESC,
          Ops Manager assigns each element of a collection a GUID when it is created to track the element lifecycle
          (e.g., to differentiate between changing an element and deleting and adding an element). 
          This works well when using the Ops Manager GUI. 
          But, this becomes a burden when customers want to maintain a common configuration across multiple 
          Ops Manager environments. The collection element GUIDs will differ between Ops Manager environments, 
          making a common configuration impossible.
          <br/>
          To address this issue, newer versions of the [<code>om</code> CLI treats certain collection element fields as logical keys](https://github.com/pivotal-cf/om/issues/207) 
          - that is, a unique identifier for an element. The <code>om</code> CLI considers collection elements with matching logical key 
          values as one and the same. With this, a customer can manage multiple Ops Manager environments with 
          a single configuration, using logical keys for collection elements instead of managing GUIDs.
          </br/>
          The om CLI will use the following fields in collection elements as logical keys:
          * <code>name</code>
          * <code>key</code>
          * <code>*name</code> (that is, any field ending in <code>name</code>)
          <br/>
          We strongly recommend including a logical key (and setting it as <code>freeze_on_deploy: true</code>) in each collection where a distinction 
          between “update” and “delete and add” operations is important. One important example is in Service Broker plans, 
          where updating a plan is very different than deleting and adding a plan 
          (which could leave existing service instances orphaned).
          DESC
      }
    ],
    additional_accessors: [
      {
        name: 'parsed_manifest(<em>named</em>)',
        description: <<~DESC,
          An array of interpolated YAML elements (often objects, but could be strings or numbers).
          Where each element of the array is an interpolation of the <code>named_manifest</code> for
          each record.
        DESC
      }
    ],
    examples: [
      {
        name: 'Example using `.value` accessor',
        image: {
          name: 'Example Product with a Collection',
          path: 'img/example-collection-tile.png'
        },
        metadata: <<~METADATA,
          property_blueprints:
            - name: users_to_add
              type: collection
              configurable: true
              property_blueprints:
                - name: name
                  type: string
                  configurable: true
                  freeze_on_deploy: true
                - name: public_key
                  type: string
                  configurable: true
                - name: sudo
                  type: boolean
                  configurable: true

          form_types:
            - name: example_form
              label: 'Example form'
              description: 'An example form'
              property_inputs:
                - reference: .properties.users_to_add
                  label: 'Users to add'
                  description: 'will added to deployed VM'
                  property_inputs:
                    - reference: name
                      label: Username
                      description: username of the added user
                    - reference: public_key
                      label: Public key
                      description: RSA public key used to SSH onto the VM
                    - reference: sudo
                      label: make sudoer
                      description: if checked, user will be able to sudo

          job_types:
            - name: example-job
              resource_label: An Example Job
              <<: *job_type_boilerplate
              templates:
                - name: user_add
                  release: os-conf
                  manifest: |
                    users: ((.properties.users_to_add.value))
        METADATA
        manifest_snippet: <<~MANIFEST_SNIPPET,
          ...
          instance_groups:
          - name: example-job
            jobs:
            - name: user_add
              release: os-conf
              ...
              properties:
                users:
                - name: tom
                  public_key: ssh-rsa MFwwDQYJKoZIhvcNAQEBBQ...
                  sudo: false
                - name: sameer
                  public_key: ssh-rsa MFwwDQYJKoZIhvcNAQEBBQ...
                  sudo: true
          ...
        MANIFEST_SNIPPET
      },
      {
        name: 'Example with `.parsed_manifest(name)`',
        image: {
          name: 'Example Product with a Collection',
          path: 'img/example-tile-with-collection-with-parsed-manifest.png'
        },
        metadata: <<~METADATA,
          property_blueprints:
            - name: sysctls
              type: collection
              configurable: true
              property_blueprints:
                - name: setting_name
                  type: string
                  configurable: true
                  freeze_on_deploy: true
                - name: setting_value
                  type: string
                  configurable: true
              named_manifests:
                - name: name_value_format
                  manifest: (( current_record.setting_name.value ))=(( current_record.setting_value.value ))

          form_types:
            - name: example_form
              label: 'Example form'
              description: 'An example form'
              property_inputs:
                - reference: .properties.sysctls
                  label: 'Custom sysctls'
                  description: 'sysctl configuration settings to be placed in /etc/sysctl.d'
                  property_inputs:
                    - reference: setting_name
                      label: Setting name
                      description: the sysctl setting name, e.g. net.core.somaxconn
                    - reference: setting_value
                      label: Setting value
                      description: value for this sysctl setting

          job_types:
            - name: example-job
              resource_label: An Example Job
              <<: *job_type_boilerplate
              templates:
                - name: sysctl
                  release: os-conf
                  manifest: |
                    sysctl: (( .properties.sysctls.parsed_manifest(name_value_format) ))
        METADATA
        manifest_snippet: <<~MANIFEST_SNIPPET,
          ...
          instance_groups:
          - name: example-job
            jobs:
            - name: sysctl
              release: os-conf
              ...
              properties:
                sysctl:
                - foo=bar
                - fooz=baz
          ...
        MANIFEST_SNIPPET
      }
    ],
} %>
